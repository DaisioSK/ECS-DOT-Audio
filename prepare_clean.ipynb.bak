{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Prepare Clean (Glass + Gunshot) / 准备清理版（玻璃+枪声）\n",
    "\n",
    "- 基于 `prepare.ipynb` 复制整理：去重 config/helper、按阶段分组，保持主逻辑不变。\n",
    "- 下一步会逐步把关键步骤 API 化到 `src/`，供 infer 在线复用。\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e448d917",
   "metadata": {},
   "source": [
    "## Imports / 导入"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "bd4658ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "import wave\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "from pathlib import Path\n",
    "import librosa\n",
    "import re\n",
    "from IPython.display import Audio, display\n",
    "from src.meta_utils import load_meta_files, map_canonical_labels, deduplicate_meta, sample_gunshot_even, stratified_folds\n",
    "from src.viz import plot_wave_and_mel\n",
    "from src.cache_utils import build_cache_index, GLASS_PIPELINE_PLAN\n",
    "from src.datasets import balance_folds\n",
    "from src.augment_pipeline import run_pipeline, PIPELINE_REGISTRY\n",
    "from src.data_utils import load_audio, generate_aligned_windows, trim_silence, log_mel_spectrogram\n",
    "from src.config import TARGET_LABELS, POSITIVE_LABELS, SEED, SR, PROJECT_ROOT, N_MELS, HOP_LENGTH, BACKGROUND_LABEL, CACHE_ROOT, CACHE_MEL64, META_FILES, RAW_AUDIO_ROOTS, WINDOW_PARAMS\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Config / 配置（集中）\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Config (single source of truth)\n",
    "# Keep all run parameters here. 统一把本次运行参数放在这里。\n",
    "\n",
    "META_FILES = META_FILES  # from config\n",
    "LABEL_MAP = POSITIVE_LABELS\n",
    "K_FOLDS = 5\n",
    "RATIOS = {'glass': 3, 'gunshot': 3, 'background': 4}\n",
    "MAX_DURATION = 6.0  # seconds\n",
    "GUNSHOT_TARGET = 90  # total gunshot clips after sampling\n",
    "TARGET_SR = SR\n",
    "RESAMPLED_ROOT = CACHE_ROOT / 'data_resampled'\n",
    "INCLUDE_SOURCES = ['esc50', 'gunshot_kaggle']\n",
    "TARGET_FRAMES = 84\n",
    "\n",
    "# Windowing / energy thresholds (used by windowing + QA)\n",
    "WINDOW_SECONDS = 1.0\n",
    "WINDOW_HOP = 0.5\n",
    "ENERGY_THRESHOLD = 0.3\n",
    "PEAK_RATIO_THRESHOLD = 0.8\n",
    "FRONT_PEAK_RATIO = 0.5\n",
    "EXTRA_SHIFTS = (-0.1, 0.1)\n",
    "TRIM_SILENCE_BEFORE = True\n",
    "TRIM_TOP_DB = 20.0\n",
    "TRIM_MIN_KEEP_SECONDS = 0.2\n",
    "cfg_rows = [\n",
    "    ('WINDOW_SECONDS', WINDOW_SECONDS, 'window length (s): longer=more context, shorter=less latency but may miss long events'),\n",
    "    ('WINDOW_HOP', WINDOW_HOP, 'hop (s): smaller=denser windows, larger=fewer windows/less overlap'),\n",
    "    ('ENERGY_THRESHOLD', ENERGY_THRESHOLD, 'energy mask threshold (relative): higher=drop quiet windows, lower=keep more'),\n",
    "    ('PEAK_RATIO_THRESHOLD', PEAK_RATIO_THRESHOLD, 'peak energy ratio (relative to clip): higher=only strong peaks kept'),\n",
    "    ('FRONT_PEAK_RATIO', FRONT_PEAK_RATIO, 'peak position limit (0-1): lower=peaks must be earlier'),\n",
    "    ('EXTRA_SHIFTS', EXTRA_SHIFTS, 'fallback shifts (s) when no peak windows kept'),\n",
    "    ('TRIM_SILENCE_BEFORE', TRIM_SILENCE_BEFORE, 'apply silence trim before windowing'),\n",
    "    ('TRIM_TOP_DB', TRIM_TOP_DB, 'trim threshold dB: higher=more aggressive trimming'),\n",
    "    ('TRIM_MIN_KEEP_SECONDS', TRIM_MIN_KEEP_SECONDS, 'min segment kept after trim (s)')\n",
    "]\n",
    "print('Windowing / energy config:')\n",
    "for k,v,desc in cfg_rows:\n",
    "    print(f'- {k}: {v} -> {desc}')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Helpers / 辅助函数（集中）\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Helpers (shared across cells)\n",
    "# 只放“纯 helper”，不依赖临时变量（例如 bg_pool/rng 这种仍留在原 cell 内）。\n",
    "\n",
    "from typing import Any\n",
    "\n",
    "\n",
    "def parse_weapon(extra: str) -> str:\n",
    "    \"\"\"Parse weapon_id=XXX from extra_meta string.\"\"\"\n",
    "    if not isinstance(extra, str):\n",
    "        return \"unknown\"\n",
    "    m = re.search(r\"weapon_id=([^,;]+)\", extra)\n",
    "    return m.group(1).strip() if m else \"unknown\"\n",
    "\n",
    "\n",
    "def _quantile95(x):\n",
    "    return x.quantile(0.95)\n",
    "\n",
    "\n",
    "def compute_energy_detail(sub_df: pd.DataFrame, sample_n: int = 80) -> pd.DataFrame:\n",
    "    \"\"\"Sample clips and compute duration/RMS peak/peak position/active ratio.\"\"\"\n",
    "    rows: list[dict[str, Any]] = []\n",
    "    if len(sub_df) == 0:\n",
    "        return pd.DataFrame(rows)\n",
    "    sample = sub_df.sample(n=min(sample_n, len(sub_df)), random_state=SEED)\n",
    "    for _, r in sample.iterrows():\n",
    "        y, sr = load_audio(r, sr=TARGET_SR)\n",
    "        if TRIM_SILENCE_BEFORE:\n",
    "            y = trim_silence(y, sr, top_db=TRIM_TOP_DB, min_keep_seconds=TRIM_MIN_KEEP_SECONDS)\n",
    "        frame_length = min(2048, int(WINDOW_SECONDS * sr))\n",
    "        hop = int(WINDOW_HOP * sr)\n",
    "        rms = librosa.feature.rms(y=y, frame_length=frame_length, hop_length=hop)[0]\n",
    "        if rms.size == 0 or rms.max() <= 0:\n",
    "            continue\n",
    "        peak_idx = int(np.argmax(rms))\n",
    "        peak_pos = peak_idx / max(len(rms) - 1, 1)\n",
    "        active_ratio = float((rms > (rms.max() * ENERGY_THRESHOLD)).sum()) / len(rms)\n",
    "        rows.append({\n",
    "            'duration': len(y) / sr,\n",
    "            'rms_max': float(rms.max()),\n",
    "            'peak_pos': peak_pos,\n",
    "            'active_ratio': active_ratio,\n",
    "        })\n",
    "    return pd.DataFrame(rows)\n",
    "\n",
    "\n",
    "def resolve_audio_from_row(row: dict | pd.Series, sr: int = TARGET_SR):\n",
    "    \"\"\"Return (y, sr) using in-row audio if present, else load_audio(row).\"\"\"\n",
    "    audio = None\n",
    "    if isinstance(row, dict):\n",
    "        audio = row.get('audio')\n",
    "    else:\n",
    "        audio = row.get('audio') if 'audio' in row else None\n",
    "    if audio is not None:\n",
    "        return audio, sr\n",
    "    return load_audio(row, sr=sr)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "24f9c515",
   "metadata": {},
   "source": [
    "## Load, map, dedup / 读取映射去重\n",
    "- Load meta CSVs\n",
    "- Map raw labels to canonical labels\n",
    "- Deduplicate by md5/filepath\n",
    "- Summary counts\n",
    "\n",
    "读取 meta，映射标签，按 md5/路径去重，打印汇总。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "meta_df = load_meta_files(META_FILES)\n",
    "meta_df = map_canonical_labels(meta_df, label_map=LABEL_MAP, target_labels=TARGET_LABELS)\n",
    "meta_df = deduplicate_meta(meta_df, subset=['md5','filepath'])\n",
    "print('Total rows after dedup:', len(meta_df))\n",
    "print('By source (all):', meta_df['source'].value_counts().to_dict(),'\\n')\n",
    "\n",
    "INCLUDE_SOURCES = ['esc50', 'gunshot_kaggle']\n",
    "working_df = meta_df[meta_df['source'].isin(INCLUDE_SOURCES)].copy()\n",
    "holdout_df = meta_df[~meta_df['source'].isin(INCLUDE_SOURCES)].copy()\n",
    "print('Working sources:', INCLUDE_SOURCES, '->', working_df['source'].value_counts().to_dict())\n",
    "print('Working labels:', working_df['canonical_label'].value_counts().to_dict())\n",
    "print('Holdout sources:', holdout_df['source'].value_counts().to_dict())\n",
    "print('Holdout labels:', holdout_df['canonical_label'].value_counts().to_dict())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ef68b583",
   "metadata": {},
   "source": [
    "## Filter & gunshot sampling / 过滤与枪声抽样\n",
    "- Drop clips longer than MAX_DURATION\n",
    "- Evenly sample gunshot across weapon_id to total GUNSHOT_TARGET\n",
    "\n",
    "过滤 >MAX_DURATION；枪声按 weapon_id 均匀抽样，总数 GUNSHOT_TARGET。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "clean_df = working_df[working_df['duration_sec'] <= MAX_DURATION].copy()\n",
    "gun_sampled = sample_gunshot_even(clean_df, target_label='gunshot', total=GUNSHOT_TARGET, seed=SEED)\n",
    "if not gun_sampled.empty:\n",
    "    gun_stats = gun_sampled.groupby('source').size().to_dict()\n",
    "    weapon_stats = gun_sampled.apply(lambda r: Path(str(r.get('filepath',''))).parent.name, axis=1).value_counts().to_dict()\n",
    "    print('Gunshot sampled per source:', gun_stats)\n",
    "    print('Gunshot sampled per weapon_id (from parent folder):', weapon_stats, '\\n')\n",
    "    \n",
    "non_gun = clean_df[clean_df['canonical_label'] != 'gunshot']\n",
    "clean_df = pd.concat([non_gun, gun_sampled], ignore_index=True)\n",
    "print(f'Label counts: （{len(clean_df)})', clean_df['canonical_label'].value_counts().to_dict())\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eed8d916",
   "metadata": {},
   "source": [
    "## Resample to 22.05k mono / 重采样为22.05k单声道\n",
    "Write resampled audio to cache/data_resampled and build resampled_df. 将重采样音频写到 cache/data_resampled，并生成 resampled_df。\n",
    "⚠️ Loads & writes all clips; may take time/disk. 需加载并写出全部音频，耗时且占用磁盘。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "RESAMPLED_ROOT = RESAMPLED_ROOT\n",
    "resampled_rows = []\n",
    "for _, r in clean_df.iterrows():\n",
    "    y_rs, sr_rs = load_audio(r, sr=TARGET_SR)\n",
    "    rel = Path(r['filepath'])\n",
    "    if rel.is_absolute():\n",
    "        rel = rel.relative_to(PROJECT_ROOT)\n",
    "    dst_path = RESAMPLED_ROOT / rel\n",
    "    dst_path.parent.mkdir(parents=True, exist_ok=True)\n",
    "    y_int16 = (y_rs * 32767).clip(-32768, 32767).astype('int16')\n",
    "    with wave.open(dst_path.as_posix(), 'wb') as wf:\n",
    "        wf.setnchannels(1)\n",
    "        wf.setsampwidth(2)\n",
    "        wf.setframerate(TARGET_SR)\n",
    "        wf.writeframes(y_int16.tobytes())\n",
    "    frames = len(y_int16)\n",
    "    resampled_rows.append({\n",
    "        'sno': r.get('sno', len(resampled_rows)+1),\n",
    "        'raw_filepath': rel.as_posix(),\n",
    "        'filepath': dst_path.relative_to(PROJECT_ROOT).as_posix(),\n",
    "        'label': r.get('label'),\n",
    "        'canonical_label': r.get('canonical_label'),\n",
    "        'source': r.get('source'),\n",
    "        'fold_id': r.get('fold_id',''),\n",
    "        'duration_sec': round(frames / TARGET_SR, 3),\n",
    "        'duration_samples': frames,\n",
    "        'sr': TARGET_SR,\n",
    "        'channels': 1,\n",
    "        'bit_depth': 16,\n",
    "        'md5': '',\n",
    "        'extra_meta': r.get('extra_meta',''),\n",
    "    })\n",
    "resampled_df = pd.DataFrame(resampled_rows)\n",
    "resampled_df['target_label'] = resampled_df['canonical_label']\n",
    "print('Resampled rows:', len(resampled_df))\n",
    "print('sr/ch after resample:', resampled_df['sr'].unique(), resampled_df['channels'].unique())\n",
    "print('Label counts:', resampled_df['target_label'].value_counts().to_dict())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Optional: save holdout meta for later use\n",
    "if len(holdout_df) > 0:\n",
    "    holdout_path = RESAMPLED_ROOT / 'holdout_meta.csv'\n",
    "    holdout_path.parent.mkdir(parents=True, exist_ok=True)\n",
    "    holdout_df.to_csv(holdout_path, index=False)\n",
    "    print('Saved holdout meta to', holdout_path)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "831c0d7f",
   "metadata": {},
   "source": [
    "## Listen: before vs after / 试听前后\n",
    "Play original vs resampled audio for a few samples. 对比播放原始与重采样音频。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "samples = resampled_df.sample(n=min(5, len(resampled_df)), random_state=SEED)\n",
    "for _, r in samples.iterrows():\n",
    "    y_after, sr_after = load_audio(r, sr=TARGET_SR)\n",
    "    raw_rel = Path(r.get('raw_filepath', r['filepath']))\n",
    "    raw_path = PROJECT_ROOT / raw_rel if not raw_rel.is_absolute() else raw_rel\n",
    "    y_before, sr_before = (None, None)\n",
    "    if raw_path.exists():\n",
    "        y_before, sr_before = load_audio({'filepath': raw_path}, sr=None)\n",
    "    print('Sample:', r.get('target_label',''), '|', raw_rel)\n",
    "    if y_before is not None:\n",
    "        display(Audio(y_before, rate=sr_before))\n",
    "    display(Audio(y_after, rate=sr_after))\n",
    "    print('-'*40)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ff2129c",
   "metadata": {},
   "source": [
    "## 给 Audio 进行分折\n",
    "- 在audio层进行分折，可以避免同一个audio切窗之后混入不同的 fold\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "folded_df = stratified_folds(resampled_df, k=K_FOLDS, seed=SEED, group_key='canonical_label', sub_key='weapon', fold_column='fold_id')\n",
    "print('Fold distribution (counts):', folded_df['fold_id'].value_counts().to_dict())\n",
    "fold_pivot = folded_df.pivot_table(index='target_label', columns='fold_id', values='filepath', aggfunc='count').fillna(0).astype(int)\n",
    "print('Label x fold (counts):')\n",
    "display(fold_pivot)\n",
    "\n",
    "# 从 extra_meta 中提取 weapon_id=XXXX 的值\n",
    "gun_df = folded_df[folded_df['canonical_label'] == 'gunshot'].copy()\n",
    "gun_df[\"weapon\"] = gun_df[\"extra_meta\"].apply(parse_weapon)\n",
    "weapon_fold = gun_df.pivot_table(\n",
    "    index=\"weapon\",\n",
    "    columns=\"fold_id\",\n",
    "    values=\"filepath\",\n",
    "    aggfunc=\"count\",\n",
    "    fill_value=0\n",
    ").astype(int)\n",
    "print(\"\\nWeapon x fold (counts):\")\n",
    "display(weapon_fold)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "47397065",
   "metadata": {},
   "source": [
    "### Detailed energy/peak stats / 能量与峰值细查 (统计峰值位置、活跃占比，辅助判断窗口/裁剪参数)。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from functools import partial\n",
    "\n",
    "# Defaults if config cell not run yet\n",
    "WINDOW_SECONDS = globals().get('WINDOW_SECONDS', 1.0)\n",
    "WINDOW_HOP = globals().get('WINDOW_HOP', 0.5)\n",
    "ENERGY_THRESHOLD = globals().get('ENERGY_THRESHOLD', 0.3)\n",
    "TRIM_SILENCE_BEFORE = globals().get('TRIM_SILENCE_BEFORE', False)\n",
    "TRIM_TOP_DB = globals().get('TRIM_TOP_DB', 20.0)\n",
    "TRIM_MIN_KEEP_SECONDS = globals().get('TRIM_MIN_KEEP_SECONDS', 0.0)\n",
    "\n",
    "\n",
    "energy_detail = []\n",
    "for lbl in ['glass', 'gunshot']:\n",
    "    df_lbl = folded_df[folded_df['target_label'] == lbl]\n",
    "    stats = compute_energy_detail(df_lbl)\n",
    "    stats['label'] = lbl\n",
    "    energy_detail.append(stats)\n",
    "energy_detail = pd.concat(energy_detail, ignore_index=True)\n",
    "print('Energy detail (mean/median/95%)')\n",
    "display(energy_detail.groupby('label')[['duration', 'rms_max', 'peak_pos', 'active_ratio']].agg(['mean', 'median', _quantile95]))\n",
    "\n",
    "fig, axes = plt.subplots(1, 2, figsize=(12, 4))\n",
    "sns.histplot(data=energy_detail, x='peak_pos', hue='label', bins=20, ax=axes[0], element='step')\n",
    "axes[0].set_title('Peak position (0=start, 1=end)')\n",
    "sns.histplot(data=energy_detail, x='active_ratio', hue='label', bins=20, ax=axes[1], element='step')\n",
    "axes[1].set_title('Active ratio (RMS > threshold)')\n",
    "plt.tight_layout(); plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e77f1b4c",
   "metadata": {},
   "source": [
    "## Base window summary / 基础分窗统计\n",
    "Generate aligned windows for glass & gunshot, count per clip. 对玻璃/枪声分窗，统计每clip窗口数。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "records = []\n",
    "labels_for_align = ['glass', 'gunshot']\n",
    "all_labels = sorted(folded_df['target_label'].unique().tolist())\n",
    "subset = folded_df[folded_df['target_label'].isin(all_labels)]\n",
    "for _, row in subset.iterrows():\n",
    "    wins = generate_aligned_windows(\n",
    "        row,\n",
    "        align_labels=labels_for_align,\n",
    "        extra_shifts=EXTRA_SHIFTS,\n",
    "        energy_threshold=ENERGY_THRESHOLD,\n",
    "        peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "        front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "        trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "        trim_top_db=TRIM_TOP_DB,\n",
    "        trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "        label_params=WINDOW_PARAMS,\n",
    "    )\n",
    "    records.append({\n",
    "        'label': row['target_label'],\n",
    "        'fold': row.get('fold_id', -1),\n",
    "        'clip': Path(row['filepath']).stem,\n",
    "        'n_windows': len(wins),\n",
    "    })\n",
    "base_df = pd.DataFrame(records)\n",
    "\n",
    "# 简单键值统计：每类多少个窗口\n",
    "if base_df.empty:\n",
    "    print('No windows found')\n",
    "else:\n",
    "    total_windows = int(base_df['n_windows'].sum())\n",
    "    print(f\"Total clips: {len(base_df)}, total windows: {total_windows}\")\n",
    "    label_windows = base_df.groupby('label')['n_windows'].sum().reindex(all_labels, fill_value=0)\n",
    "    print(\"\\nWindows per label:\")\n",
    "    for lbl, cnt in label_windows.to_dict().items():\n",
    "        print(f\"  {lbl}: {int(cnt)}\")\n",
    "\n",
    "    if 'fold' in base_df.columns:\n",
    "        fold_totals = base_df.pivot_table(index='fold', columns='label', values='n_windows', aggfunc='sum').fillna(0)\n",
    "        print(\"\\nWindows per fold x label (total windows):\")\n",
    "        display(fold_totals)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d8293df3",
   "metadata": {},
   "source": [
    "## Window QA visualization / 分窗可视化QA\n",
    "Plot waveform+RMS with kept window boundaries for one glass and one gunshot sample. 对玻璃/枪声各选一条，画波形+RMS并标出保留的窗口边界。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "SEED = 5\n",
    "\n",
    "\n",
    "## Window QA (combined viz + listening) / 分窗 QA（可视化+试听）\n",
    "# Sample one glass, one gunshot, one background (if available); visualize windows and listen to kept windows.\n",
    "samples_cfg = ['glass','gunshot', BACKGROUND_LABEL]\n",
    "samples = []\n",
    "for lbl in samples_cfg:\n",
    "    subset = folded_df[folded_df['target_label']==lbl]\n",
    "    if len(subset) == 0:\n",
    "        continue\n",
    "    samples.append(subset.sample(random_state=SEED).iloc[0])\n",
    "if not any(s.get('target_label') == BACKGROUND_LABEL for s in samples):\n",
    "    bg_pool = folded_df[~folded_df['target_label'].isin(['glass','gunshot'])]\n",
    "    if len(bg_pool) > 0:\n",
    "        samples.append(bg_pool.sample(random_state=SEED).iloc[0])\n",
    "if len(samples) == 0:\n",
    "    print('No samples available for QA')\n",
    "else:\n",
    "    for idx, row in enumerate(samples):\n",
    "        print(f\"\\n=== Sample {idx+1}: {row.get('target_label','')} | {row.get('source','')} | {row.get('filepath','')}\")\n",
    "        y, sr = load_audio(row, sr=TARGET_SR)\n",
    "        print(f\"Full clip ({len(y)/sr:.2f}s)\")\n",
    "        display(Audio(y, rate=sr))\n",
    "        # 记录窗口决策日志\n",
    "        logs = []\n",
    "        wins = generate_aligned_windows(\n",
    "            row,\n",
    "            align_labels=['glass','gunshot'],\n",
    "            extra_shifts=EXTRA_SHIFTS,\n",
    "            energy_threshold=ENERGY_THRESHOLD,\n",
    "            peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "            front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "            trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "            trim_top_db=TRIM_TOP_DB,\n",
    "            trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "            label_params=WINDOW_PARAMS,\n",
    "            debug=True,\n",
    "            debug_sink=logs,\n",
    "        )\n",
    "        # 打印日志表，便于查看被丢弃原因\n",
    "        if logs:\n",
    "            import pandas as pd\n",
    "            display(pd.DataFrame(logs))\n",
    "        # 记录修剪前后长度\n",
    "        if TRIM_SILENCE_BEFORE:\n",
    "            y_trim = trim_silence(y, sr, top_db=TRIM_TOP_DB, min_keep_seconds=TRIM_MIN_KEEP_SECONDS)\n",
    "            print(f\"Length raw={len(y)/sr:.2f}s after_trim={len(y_trim)/sr:.2f}s\")\n",
    "        hop_len = int(WINDOW_HOP * sr)\n",
    "        win_len = int(WINDOW_SECONDS * sr)\n",
    "        fig, axes = plt.subplots(1, 2, figsize=(10, 3))\n",
    "        times = np.arange(len(y)) / sr\n",
    "        axes[0].plot(times, y)\n",
    "        axes[0].set_title(f\"{row['target_label']} | {row['source']} | windows={len(wins)}\")\n",
    "        axes[0].set_xlabel('Time [s]')\n",
    "        axes[0].set_ylabel('Amp')\n",
    "        rms = librosa.feature.rms(y=y, frame_length=2048, hop_length=256)[0]\n",
    "        rms_times = (np.arange(len(rms)) * 256) / sr\n",
    "        axes[0].plot(rms_times, rms, alpha=0.7)\n",
    "        # 使用日志中的 start_sec 标记被保留的窗口\n",
    "        kept_starts = [l['start_sec'] for l in logs if l.get('status') == 'keep' and l.get('start_sec') is not None]\n",
    "        for start_sec in kept_starts:\n",
    "            axes[0].axvspan(start_sec, start_sec + WINDOW_SECONDS, color='red', alpha=0.2)\n",
    "        mel = log_mel_spectrogram(y, sr, n_fft=HOP_LENGTH*4, hop_length=HOP_LENGTH, n_mels=N_MELS)\n",
    "        axes[1].imshow(mel, aspect='auto', origin='lower')\n",
    "        axes[1].set_title(f'Log-mel {mel.shape}')\n",
    "        axes[1].set_xlabel('Frames')\n",
    "        axes[1].set_ylabel('Mel bins')\n",
    "        plt.tight_layout(); plt.show()\n",
    "        for w_idx, w in enumerate(wins):\n",
    "            start = kept_starts[w_idx] if w_idx < len(kept_starts) else w_idx * hop_len / sr\n",
    "            end = start + WINDOW_SECONDS\n",
    "            print(f\"Play window {w_idx}: {start:.2f}s - {end:.2f}s\")\n",
    "            display(Audio(w, rate=sr))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "49b20c79",
   "metadata": {},
   "source": [
    "## Play 10 event windows / 播放10个事件窗口\n",
    "Play up to 10 kept windows (glass/gunshot) for quick QA. 播放最多10个保留窗口，便于快速听检。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "clips = folded_df[folded_df['target_label'].isin(['glass','gunshot'])].sample(frac=1.0, random_state=SEED)\n",
    "played = 0\n",
    "for _, row in clips.iterrows():\n",
    "    wins = generate_aligned_windows(\n",
    "        row,\n",
    "        align_labels=['glass','gunshot'],\n",
    "        extra_shifts=EXTRA_SHIFTS,\n",
    "        energy_threshold=ENERGY_THRESHOLD,\n",
    "        peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "        front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "        trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "        trim_top_db=TRIM_TOP_DB,\n",
    "        trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "        label_params=WINDOW_PARAMS,\n",
    "    )\n",
    "    for w_idx, w in enumerate(wins):\n",
    "        print('{} | {} | window {}'.format(row['target_label'], Path(row['filepath']).stem, w_idx))\n",
    "        display(Audio(w, rate=TARGET_SR))\n",
    "        played += 1\n",
    "        if played >= 10:\n",
    "            break\n",
    "    if played >= 10:\n",
    "        break\n",
    "if played == 0:\n",
    "    print('No windows to play')\n",
    "\n",
    "if not wins:\n",
    "    print('No windows to inspect for shape')\n",
    "else:\n",
    "    mel = log_mel_spectrogram(wins[0], sr=TARGET_SR)\n",
    "    print(f'log-mel shape: {mel.shape}; model input: (batch, 1, {mel.shape[0]}, {mel.shape[1]})')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ba2e6396",
   "metadata": {},
   "source": [
    "## 整合原始window数据"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Build window-level dataframe (one row per window)\n",
    "window_records = []\n",
    "labels_for_align = TARGET_LABELS  # 正类对齐峰值，其余走背景逻辑\n",
    "for _, row in folded_df.iterrows():\n",
    "    wins = generate_aligned_windows(\n",
    "        row,\n",
    "        align_labels=labels_for_align,\n",
    "        extra_shifts=EXTRA_SHIFTS,\n",
    "        energy_threshold=ENERGY_THRESHOLD,\n",
    "        peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "        front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "        trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "        trim_top_db=TRIM_TOP_DB,\n",
    "        trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "        label_params=WINDOW_PARAMS,\n",
    "    )\n",
    "    base_label = row.get('canonical_label', row.get('target_label', 'unknown'))\n",
    "    mapped_label = base_label if base_label in TARGET_LABELS else BACKGROUND_LABEL\n",
    "    clip_id = Path(row['filepath']).stem\n",
    "    for w_idx, w in enumerate(wins):\n",
    "        start_sec = w_idx * WINDOW_HOP\n",
    "        end_sec = start_sec + WINDOW_SECONDS\n",
    "        window_records.append({\n",
    "            'clip_id': clip_id,\n",
    "            'window_id': f\"w{w_idx}\",\n",
    "            'fold_id': row.get('fold_id', -1),\n",
    "            'source': row.get('source', ''),\n",
    "            'orig_label': base_label,\n",
    "            'target_label': mapped_label,\n",
    "            'start_sec': start_sec,\n",
    "            'end_sec': end_sec,\n",
    "            'length_sec': WINDOW_SECONDS,\n",
    "            'filepath': row.get('filepath'),\n",
    "            'raw_filepath': row.get('raw_filepath'),\n",
    "        })\n",
    "\n",
    "window_df = pd.DataFrame(window_records)\n",
    "print(f\"Total windows: {len(window_df)}\")\n",
    "label_totals = window_df['target_label'].value_counts().to_dict()\n",
    "print(\"Windows per label (total):\")\n",
    "for k, v in label_totals.items():\n",
    "    print(f\"  {k}: {v}\")\n",
    "\n",
    "if 'fold_id' in window_df.columns:\n",
    "    print(\"\\nFold x label (total windows):\")\n",
    "    pivot = window_df.pivot_table(index='fold_id', columns='target_label', values='window_id', aggfunc='count').fillna(0)\n",
    "    print(pivot.to_string())\n",
    "\n",
    "\n",
    "display(window_df[:5])\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae73ce5c",
   "metadata": {},
   "source": [
    "## Augment plan & cache dirs / 增强计划与缓存目录\n",
    "设定 pipeline、对齐标签、Smoke/Full 输出目录。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "PIPELINE_PLAN = GLASS_PIPELINE_PLAN\n",
    "# ALIGN_LABELS = CACHE_ALIGN_LABELS\n",
    "SMOKE_CACHE_DIR = CACHE_MEL64 / 'mel64_smoke_multi'\n",
    "FULL_CACHE_DIR = CACHE_MEL64 / 'mel64_multi'\n",
    "SMOKE_COUNTS = {'glass': 10, 'gunshot': 10, 'background': 20}\n",
    "print('Pipeline:', PIPELINE_PLAN)\n",
    "print('Smoke dir:', SMOKE_CACHE_DIR)\n",
    "print('Full dir:', FULL_CACHE_DIR)\n",
    "\n",
    "# # 如未定义这些参数，给个默认兜底\n",
    "# EXTRA_SHIFTS = globals().get(\"EXTRA_SHIFTS\", ())\n",
    "# ENERGY_THRESHOLD = globals().get(\"ENERGY_THRESHOLD\", 0.3)\n",
    "# PEAK_RATIO_THRESHOLD = globals().get(\"PEAK_RATIO_THRESHOLD\", 0.8)\n",
    "# FRONT_PEAK_RATIO = globals().get(\"FRONT_PEAK_RATIO\", 0.5)\n",
    "# TRIM_SILENCE_BEFORE = globals().get(\"TRIM_SILENCE_BEFORE\", True)\n",
    "# TRIM_TOP_DB = globals().get(\"TRIM_TOP_DB\", 20.0)\n",
    "# TRIM_MIN_KEEP_SECONDS = globals().get(\"TRIM_MIN_KEEP_SECONDS\", 0.2)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7c3f5a2c",
   "metadata": {},
   "source": [
    "## Listen: base vs aug (smoke) / 试听增强样本\n",
    "抽样 glass/gunshot 各 1 条，播放 base 和各 pipeline 增强（mix 会抽背景）。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "rng = np.random.default_rng(SEED)\n",
    "bg_pool = window_df[window_df['target_label'] == BACKGROUND_LABEL]\n",
    "\n",
    "def sample_bg_chunk(length):\n",
    "    if bg_pool.empty:\n",
    "        return None\n",
    "    row = bg_pool.sample(random_state=SEED).iloc[0]\n",
    "    y_bg, _ = load_audio(row, sr=TARGET_SR)\n",
    "    if len(y_bg) < length:\n",
    "        y_bg = np.pad(y_bg, (0, length - len(y_bg)))\n",
    "    start = rng.integers(0, max(1, len(y_bg) - length + 1))\n",
    "    return y_bg[start:start+length]\n",
    "\n",
    "for lbl in ['glass','gunshot']:\n",
    "    sub = window_df[window_df['target_label'] == lbl]\n",
    "    if sub.empty:\n",
    "        continue\n",
    "    row = sub.sample(random_state=SEED).iloc[0]\n",
    "    wins = generate_aligned_windows(\n",
    "        row,\n",
    "        align_labels=['glass','gunshot'],\n",
    "        extra_shifts=EXTRA_SHIFTS,\n",
    "        energy_threshold=ENERGY_THRESHOLD,\n",
    "        peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "        front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "        trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "        trim_top_db=TRIM_TOP_DB,\n",
    "        trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "        label_params=WINDOW_PARAMS,\n",
    "    )\n",
    "    wins = generate_aligned_windows(\n",
    "        row,\n",
    "        align_labels=labels_for_align,\n",
    "        extra_shifts=EXTRA_SHIFTS,\n",
    "        energy_threshold=ENERGY_THRESHOLD,\n",
    "        peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "        front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "        trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "        trim_top_db=TRIM_TOP_DB,\n",
    "        trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "        label_params=WINDOW_PARAMS,\n",
    "    )\n",
    "    if not wins:\n",
    "        continue\n",
    "    base = wins[0]\n",
    "    print(f\"Label={lbl} | clip={Path(row['filepath']).stem} | base\")\n",
    "    display(Audio(base, rate=TARGET_SR))\n",
    "    for name, cfg in PIPELINE_REGISTRY.items():\n",
    "        bg = None\n",
    "        if 'mix' in PIPELINE_REGISTRY[name]:\n",
    "            bg = sample_bg_chunk(len(base))\n",
    "        aug = run_pipeline(base, name, background=bg)\n",
    "        print(f\" -> {name}\")\n",
    "        display(Audio(aug.audio, rate=TARGET_SR))\n",
    "    print('-'*40)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "507c7c93-3f4c-4056-9da4-4b60feea5b7e",
   "metadata": {},
   "source": [
    "## 选出 target window，并使用数据增强扩充"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Augment windows per fold/label (base included), no background mixing\n",
    "# Assumes PIPELINE_REGISTRY, TARGET_LABELS, WINDOW_PARAMS, TARGET_SR 等已定义\n",
    "TARGET_PER_FOLD = {'glass': 250, 'gunshot': 250}\n",
    "plan_names = list(PIPELINE_REGISTRY.keys())\n",
    "rng = np.random.default_rng(SEED)\n",
    "aug_records = []\n",
    "\n",
    "for lab, target in TARGET_PER_FOLD.items():\n",
    "    for fold, group in folded_df[folded_df['canonical_label'] == lab].groupby('fold_id'):\n",
    "        win_pool = []\n",
    "        for _, row in group.iterrows():\n",
    "            wins = generate_aligned_windows(\n",
    "                row,\n",
    "                align_labels=TARGET_LABELS,\n",
    "                extra_shifts=EXTRA_SHIFTS,\n",
    "                energy_threshold=ENERGY_THRESHOLD,\n",
    "                peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "                front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "                trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "                trim_top_db=TRIM_TOP_DB,\n",
    "                trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "                label_params=WINDOW_PARAMS,\n",
    "            )\n",
    "            clip_id = Path(row['filepath']).stem\n",
    "            for w_idx, w in enumerate(wins):\n",
    "                win_pool.append((clip_id, w_idx, w, row))\n",
    "        if not win_pool:\n",
    "            continue\n",
    "\n",
    "        # 1) 写入全部 base，不计入 target\n",
    "        for clip_id, w_idx, w, row in win_pool:\n",
    "            aug_records.append({\n",
    "                'clip_id': clip_id,\n",
    "                'window_id': f\"{clip_id}_w{w_idx}\",\n",
    "                'fold_id': fold,\n",
    "                'source': row.get('source',''),\n",
    "                'original_label': lab,\n",
    "                'target_label': lab,\n",
    "                'pipeline': 'base',\n",
    "                'copy': 0,\n",
    "                'length_sec': len(w) / TARGET_SR,\n",
    "                'audio': w,\n",
    "            })\n",
    "\n",
    "        # 2) 增广配额 = target - base_count\n",
    "        remaining = max(target - len(win_pool), 0)\n",
    "        if remaining == 0:\n",
    "            continue\n",
    "\n",
    "        # 覆盖阶段：每个窗口×每种 pipeline 各至少一次，消耗 remaining\n",
    "        count = 0\n",
    "        for clip_id, w_idx, w, row in win_pool:\n",
    "            for name in plan_names:\n",
    "                if count >= remaining:\n",
    "                    break\n",
    "                bg = sample_bg_chunk(len(w)) if 'mix' in PIPELINE_REGISTRY[name] else None  # 若不用混音，设 bg=None\n",
    "                aug = run_pipeline(w, name, background=bg)\n",
    "                aug_records.append({\n",
    "                    'clip_id': clip_id,\n",
    "                    'window_id': f\"{clip_id}_w{w_idx}\",\n",
    "                    'fold_id': fold,\n",
    "                    'source': row.get('source',''),\n",
    "                    'original_label': lab,\n",
    "                    'target_label': lab,\n",
    "                    'pipeline': name,\n",
    "                    'copy': 0,\n",
    "                    'length_sec': len(aug.audio) / TARGET_SR,\n",
    "                    'audio': aug.audio,\n",
    "                })\n",
    "                count += 1\n",
    "            if count >= remaining:\n",
    "                break\n",
    "\n",
    "        # 3) 若仍未达 remaining，随机窗口+随机 pipeline 补齐\n",
    "        while count < remaining:\n",
    "            idx = rng.integers(0, len(win_pool))\n",
    "            clip_id, w_idx, w, row = win_pool[idx]\n",
    "            name = rng.choice(plan_names)\n",
    "            bg = sample_bg_chunk(len(w)) if 'mix' in PIPELINE_REGISTRY[name] else None  # 若不用混音，设 bg=None\n",
    "            aug = run_pipeline(w, name, background=bg)\n",
    "            aug_records.append({\n",
    "                'clip_id': clip_id,\n",
    "                'window_id': f\"{clip_id}_w{w_idx}\",\n",
    "                'fold_id': fold,\n",
    "                'source': row.get('source',''),\n",
    "                'original_label': lab,\n",
    "                'target_label': lab,\n",
    "                'pipeline': name,\n",
    "                'copy': 0,\n",
    "                'length_sec': len(aug.audio) / TARGET_SR,\n",
    "                'audio': aug.audio,\n",
    "            })\n",
    "            count += 1\n",
    "\n",
    "aug_df = pd.DataFrame(aug_records)\n",
    "display(aug_df[:5])\n",
    "\n",
    "print(\"\\nWindows per fold x target_label x pipeline (with totals):\")\n",
    "pivot = aug_df.pivot_table(\n",
    "    index='fold_id',\n",
    "    columns=['target_label', 'pipeline'],\n",
    "    values='window_id',\n",
    "    aggfunc='count'\n",
    ").fillna(0).astype(int)\n",
    "\n",
    "pivot['total'] = pivot.sum(axis=1)\n",
    "total_row = pivot.sum(axis=0).to_frame().T\n",
    "total_row.index = ['total']\n",
    "pivot_with_totals = pd.concat([pivot, total_row])\n",
    "print(pivot_with_totals.to_string())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b255afce-bb44-41ab-91ef-1549cb62307a",
   "metadata": {},
   "source": [
    "## 均匀抽样选出 background window"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "bg_aug_records = []\n",
    "TARGET_BG_PER_FOLD = 400\n",
    "plan_names = list(PIPELINE_REGISTRY.keys())\n",
    "rng = np.random.default_rng(SEED)\n",
    "\n",
    "for fold, group in folded_df[~folded_df['canonical_label'].isin(TARGET_LABELS)].groupby('fold_id'):\n",
    "    # 切窗并分桶\n",
    "    win_by_label = {}\n",
    "    for _, row in group.iterrows():\n",
    "        wins = generate_aligned_windows(\n",
    "            row,\n",
    "            align_labels=TARGET_LABELS,  # 非正类走背景逻辑\n",
    "            extra_shifts=EXTRA_SHIFTS,\n",
    "            energy_threshold=ENERGY_THRESHOLD,\n",
    "            peak_ratio_threshold=PEAK_RATIO_THRESHOLD,\n",
    "            front_peak_ratio=FRONT_PEAK_RATIO,\n",
    "            trim_silence_before=TRIM_SILENCE_BEFORE,\n",
    "            trim_top_db=TRIM_TOP_DB,\n",
    "            trim_min_keep_seconds=TRIM_MIN_KEEP_SECONDS,\n",
    "            label_params=WINDOW_PARAMS,\n",
    "        )\n",
    "        clip_id = Path(row['filepath']).stem\n",
    "        orig_label = row.get('canonical_label', row.get('target_label', 'unknown'))\n",
    "        for w_idx, w in enumerate(wins):\n",
    "            win_by_label.setdefault(orig_label, []).append((clip_id, w_idx, w, row, orig_label))\n",
    "\n",
    "    if not win_by_label:\n",
    "        continue\n",
    "    # 打乱\n",
    "    for lab in win_by_label:\n",
    "        rng.shuffle(win_by_label[lab])\n",
    "\n",
    "    labels = sorted(win_by_label.keys())\n",
    "    n_labels = len(labels)\n",
    "    base_quota = TARGET_BG_PER_FOLD // n_labels\n",
    "    remainder = TARGET_BG_PER_FOLD % n_labels\n",
    "    count = 0\n",
    "\n",
    "    # 基准分配\n",
    "    for lab in labels:\n",
    "        pool = win_by_label[lab]\n",
    "        take_n = min(base_quota, len(pool))\n",
    "        for i in range(take_n):\n",
    "            clip_id, w_idx, w, row, orig_label = pool[i]\n",
    "            bg_aug_records.append({\n",
    "                'clip_id': clip_id,\n",
    "                'window_id': f\"{clip_id}_w{w_idx}\",\n",
    "                'fold_id': fold,\n",
    "                'source': row.get('source',''),\n",
    "                'original_label': orig_label,\n",
    "                'target_label': BACKGROUND_LABEL,\n",
    "                'pipeline': 'base',\n",
    "                'copy': 0,\n",
    "                'length_sec': len(w)/TARGET_SR,\n",
    "                'audio': w,\n",
    "            })\n",
    "            count += 1\n",
    "        win_by_label[lab] = pool[take_n:]\n",
    "\n",
    "    # 分配余数\n",
    "    rem = remainder\n",
    "    while rem > 0:\n",
    "        for lab in labels:\n",
    "            if rem <= 0:\n",
    "                break\n",
    "            pool = win_by_label[lab]\n",
    "            if pool:\n",
    "                clip_id, w_idx, w, row, orig_label = pool[0]\n",
    "                bg_aug_records.append({\n",
    "                    'clip_id': clip_id,\n",
    "                    'window_id': f\"{clip_id}_w{w_idx}\",\n",
    "                    'fold_id': fold,\n",
    "                    'source': row.get('source',''),\n",
    "                    'original_label': orig_label,\n",
    "                    'target_label': BACKGROUND_LABEL,\n",
    "                    'pipeline': 'base',\n",
    "                    'copy': 0,\n",
    "                    'length_sec': len(w)/TARGET_SR,\n",
    "                    'audio': w,\n",
    "                })\n",
    "                count += 1\n",
    "                win_by_label[lab] = pool[1:]\n",
    "                rem -= 1\n",
    "\n",
    "    # 补缺到 400：随机标签/窗口 + 随机 pipeline\n",
    "    while count < TARGET_BG_PER_FOLD:\n",
    "        lab = rng.choice(labels)\n",
    "        pool = win_by_label.get(lab, [])\n",
    "        if pool:\n",
    "            clip_id, w_idx, w, row, orig_label = pool[0]\n",
    "            win_by_label[lab] = pool[1:]\n",
    "        else:\n",
    "            # 用已加入的该标签窗口再增广\n",
    "            existing = [r for r in bg_aug_records if r['fold_id'] == fold and r['original_label'] == lab]\n",
    "            if not existing:\n",
    "                continue\n",
    "            base_row = rng.choice(existing)\n",
    "            w = base_row['audio']\n",
    "            clip_id = base_row['clip_id']\n",
    "            orig_label = base_row['original_label']\n",
    "        name = rng.choice(plan_names)\n",
    "        bg_audio = sample_bg_chunk(len(w)) if 'mix' in PIPELINE_REGISTRY[name] else None\n",
    "        aug = run_pipeline(w, name, background=bg_audio)\n",
    "        bg_aug_records.append({\n",
    "            'clip_id': clip_id,\n",
    "            'window_id': f\"{clip_id}_bg_{name}_{count}\",\n",
    "            'fold_id': fold,\n",
    "            'source': row.get('source',''),\n",
    "            'original_label': orig_label,\n",
    "            'target_label': BACKGROUND_LABEL,\n",
    "            'pipeline': name,\n",
    "            'copy': 0,\n",
    "            'length_sec': len(aug.audio)/TARGET_SR,\n",
    "            'audio': aug.audio,\n",
    "        })\n",
    "        count += 1\n",
    "\n",
    "\n",
    "bg_df = pd.DataFrame(bg_aug_records)\n",
    "display(bg_df[:5])\n",
    "bg_labels = sorted([lab for lab in folded_df['canonical_label'].unique() if lab not in TARGET_LABELS])\n",
    "print(f\"Background labels: {len(bg_labels)}, sampled windows: {len(bg_df)}\")\n",
    "\n",
    "pivot_bg = bg_df.pivot_table(\n",
    "    index='fold_id',\n",
    "    columns=['pipeline', 'original_label'],\n",
    "    values='window_id',\n",
    "    aggfunc='count'\n",
    ").fillna(0).astype(int)\n",
    "\n",
    "pivot_bg['total'] = pivot_bg.sum(axis=1)\n",
    "total_row = pivot_bg.sum(axis=0).to_frame().T\n",
    "total_row.index = ['total']\n",
    "\n",
    "pivot_bg_tot = pd.concat([pivot_bg, total_row])\n",
    "print(\"\\nBackground windows per fold x pipeline x original_label (with totals):\")\n",
    "print(pivot_bg_tot.T.to_string())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76ae8a12-f7fb-45a4-8e93-be1716174ab0",
   "metadata": {},
   "source": [
    "## 整合最终用于训练的 window 数据"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 合并正类窗口（aug_df）与背景窗口\n",
    "# display(bg_df[:5])\n",
    "# display(aug_df[:5])\n",
    "\n",
    "all_windows_df = pd.concat([aug_df, bg_df], ignore_index=True, sort=False)\n",
    "print(f\"Total windows combined: {len(all_windows_df)}\")\n",
    "print(\"By target_label:\")\n",
    "for lbl, cnt in all_windows_df['target_label'].value_counts().sort_index().items():\n",
    "    print(f\"  {lbl}: {cnt}\")\n",
    "display(all_windows_df[:5])\n",
    "\n",
    "# 如需背景的折×pipeline×原始类汇总（带总计）\n",
    "pivot_bg = all_windows_df.pivot_table(\n",
    "    index='fold_id',\n",
    "    columns=['pipeline', 'original_label'],\n",
    "    values='window_id',\n",
    "    aggfunc='count'\n",
    ").fillna(0).astype(int)\n",
    "pivot_bg['total'] = pivot_bg.sum(axis=1)\n",
    "total_row = pivot_bg.sum(axis=0).to_frame().T\n",
    "total_row.index = ['total']\n",
    "pivot_bg_tot = pd.concat([pivot_bg, total_row])\n",
    "print(\"\\nBackground windows per fold x pipeline x orig_label (with totals):\")\n",
    "print(pivot_bg_tot.T.to_string())\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "304e9648-3b15-4c50-ab72-287cb7e62d1c",
   "metadata": {},
   "source": [
    "## 训练 window 展示"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "samples_per_label = 3\n",
    "labels = ['glass', 'gunshot', BACKGROUND_LABEL]\n",
    "rows = []\n",
    "rng = np.random.default_rng(SEED)\n",
    "\n",
    "for lbl in labels:\n",
    "    subset = all_windows_df[all_windows_df['target_label'] == lbl]\n",
    "    if subset.empty:\n",
    "        continue\n",
    "    # 有放回抽样，确保凑够 samples_per_label\n",
    "    picks = subset.sample(n=samples_per_label, replace=len(subset) < samples_per_label, random_state=None)\n",
    "    rows.extend(picks.to_dict('records'))\n",
    "\n",
    "if not rows:\n",
    "    print(\"No samples available for plotting.\")\n",
    "else:\n",
    "    fig, axes = plt.subplots(3, 3, figsize=(18, 18))\n",
    "    axes = axes.flatten()\n",
    "    for idx, row in enumerate(rows[:9]):  # 防止不足 9 条\n",
    "        y, sr = resolve_audio_from_row(row, sr=TARGET_SR)\n",
    "        mel = log_mel_spectrogram(y, sr)\n",
    "        if TARGET_FRAMES is not None:\n",
    "            if mel.shape[1] > TARGET_FRAMES:\n",
    "                mel = mel[:, :TARGET_FRAMES]\n",
    "            elif mel.shape[1] < TARGET_FRAMES:\n",
    "                pad = TARGET_FRAMES - mel.shape[1]\n",
    "                mel = np.pad(mel, ((0, 0), (0, pad)), mode=\"constant\")\n",
    "        ax = axes[idx]\n",
    "        im = ax.imshow(mel, origin='lower', aspect='auto')\n",
    "        ax.set_title(\n",
    "            f\"{row.get('target_label','?')} | fold {row.get('fold_id','?')} | {row.get('pipeline','base')} | shape={mel.shape}\"\n",
    "        )\n",
    "        ax.set_xlabel('Frames')\n",
    "        ax.set_ylabel('Mel bins')\n",
    "        fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n",
    "    # 处理空格子\n",
    "    for j in range(len(rows), 9):\n",
    "        axes[j].axis('off')\n",
    "    plt.tight_layout()\n",
    "    plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "083150a9-e069-4348-82ce-ac1a495f1a8b",
   "metadata": {},
   "source": [
    "## 缓存训练 window 的 mel-log 图谱，以及输出训练目录"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "import numpy as np\n",
    "\n",
    "cache_dir = CACHE_MEL64  # 或自定义 Path(\"cache/mel64_final\")\n",
    "index_csv = PROJECT_ROOT / \"cache\" / \"window_index.csv\"\n",
    "cache_dir.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "records = []\n",
    "for _, row in all_windows_df.iterrows():\n",
    "    # 取音频\n",
    "    if 'audio' in row and row['audio'] is not None:\n",
    "        y, sr = row['audio'], TARGET_SR\n",
    "    else:\n",
    "        y, sr = load_audio(row, sr=TARGET_SR)\n",
    "\n",
    "    # 保存 mel\n",
    "    label = row.get('target_label', BACKGROUND_LABEL)\n",
    "    fold = int(row.get('fold_id', -1))\n",
    "    clip_id = row.get('clip_id', Path(str(row.get('filepath',''))).stem)\n",
    "    window_id = row.get('window_id', f\"w{_}\")\n",
    "    out_dir = cache_dir / label / f\"fold{fold}\"\n",
    "    out_dir.mkdir(parents=True, exist_ok=True)\n",
    "    cache_path = out_dir / f\"{clip_id}_{window_id}.npy\"\n",
    "    mel = log_mel_spectrogram(y, sr)\n",
    "    if TARGET_FRAMES is not None:\n",
    "        if mel.shape[1] > TARGET_FRAMES:\n",
    "            mel = mel[:, :TARGET_FRAMES]\n",
    "        elif mel.shape[1] < TARGET_FRAMES:\n",
    "            pad = TARGET_FRAMES - mel.shape[1]\n",
    "            mel = np.pad(mel, ((0, 0), (0, pad)), mode=\"constant\")\n",
    "\n",
    "    np.save(cache_path, mel.astype(np.float32))\n",
    "\n",
    "    records.append({\n",
    "        \"path\": str(cache_path.relative_to(PROJECT_ROOT)),\n",
    "        \"target_label\": label,\n",
    "        \"fold_id\": fold,\n",
    "        \"pipeline\": row.get('pipeline', 'base'),\n",
    "        \"clip_id\": clip_id,\n",
    "        \"window_id\": window_id,\n",
    "        \"source\": row.get('source', ''),\n",
    "        \"orig_label\": row.get('original_label', row.get('orig_label', label)),\n",
    "        \"length_sec\": row.get('length_sec', len(y)/sr),\n",
    "    })\n",
    "\n",
    "index_df = pd.DataFrame(records)\n",
    "index_df.to_csv(index_csv, index=False)\n",
    "print(f\"Saved {len(index_df)} windows to {cache_dir}\")\n",
    "print(f\"Index CSV: {index_csv}\")\n",
    "display(index_df.head())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from src.config import SEED, LABEL_TO_ID, BACKGROUND_LABEL, NUM_CLASSES\n",
    "\n",
    "from pathlib import Path\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "cache_dir = CACHE_MEL64  # 或 Path(\"cache/mel64_final\")\n",
    "index_csv = PROJECT_ROOT / \"cache\" / \"window_index.csv\"\n",
    "cache_dir.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "records = []\n",
    "for _, row in all_windows_df.iterrows():\n",
    "    # 音频获取\n",
    "    if 'audio' in row and row['audio'] is not None:\n",
    "        y, sr = row['audio'], TARGET_SR\n",
    "    else:\n",
    "        y, sr = load_audio(row, sr=TARGET_SR)\n",
    "\n",
    "    # 标签/多标签\n",
    "    tgt = row.get('target_label', BACKGROUND_LABEL)\n",
    "    fold = int(row.get('fold_id', -1))\n",
    "    clip_id = row.get('clip_id', Path(str(row.get('filepath', ''))).stem)\n",
    "    window_id = row.get('window_id', f\"w{_}\")\n",
    "\n",
    "    labels = [tgt] if tgt in TARGET_LABELS else []\n",
    "    label_ids = [LABEL_TO_ID[l] for l in labels]\n",
    "    main_label = labels[0] if labels else BACKGROUND_LABEL\n",
    "\n",
    "    # 计算并裁剪/填充 mel\n",
    "    mel = log_mel_spectrogram(y, sr)\n",
    "    if TARGET_FRAMES is not None:\n",
    "        if mel.shape[1] > TARGET_FRAMES:\n",
    "            mel = mel[:, :TARGET_FRAMES]\n",
    "        elif mel.shape[1] < TARGET_FRAMES:\n",
    "            pad = TARGET_FRAMES - mel.shape[1]\n",
    "            mel = np.pad(mel, ((0, 0), (0, pad)), mode=\"constant\")\n",
    "\n",
    "    # 保存 mel\n",
    "    out_dir = cache_dir / main_label / f\"fold{fold}\"\n",
    "    out_dir.mkdir(parents=True, exist_ok=True)\n",
    "    cache_path = out_dir / f\"{clip_id}_{window_id}.npy\"\n",
    "    np.save(cache_path, mel.astype(np.float32))\n",
    "\n",
    "    records.append({\n",
    "        \"path\": str(cache_path.relative_to(PROJECT_ROOT)),\n",
    "        \"target_label\": tgt,\n",
    "        \"label\": main_label,\n",
    "        \"labels\": labels,\n",
    "        \"label_ids\": label_ids,\n",
    "        \"fold_id\": fold,\n",
    "        \"pipeline\": row.get('pipeline', 'base'),\n",
    "        \"clip_id\": clip_id,\n",
    "        \"window_id\": window_id,\n",
    "        \"source\": row.get('source', ''),\n",
    "        \"shape\": mel.shape,\n",
    "        \"orig_label\": row.get('original_label', row.get('orig_label', tgt)),\n",
    "        \"length_sec\": row.get('length_sec', len(y) / sr),\n",
    "    })\n",
    "\n",
    "index_df = pd.DataFrame(records)\n",
    "index_df.to_csv(index_csv, index=False)\n",
    "print(f\"Saved {len(index_df)} windows to {cache_dir}\")\n",
    "print(f\"Index CSV: {index_csv}\")\n",
    "display(index_df.head())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 去重看有哪些组合\n",
    "unique_combos = index_df['label_ids'].apply(tuple).unique()\n",
    "print(unique_combos)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
